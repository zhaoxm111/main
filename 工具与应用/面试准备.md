一、vue准备

1. 使用vue和jquery的区别
2. mvvm的理解
3. vue如何实现响应式,如何监听事件变化
4. vue如何解析模版,指令如何处理
5. vue的整个实现流程,vue如何渲染成html,以及过程
6. 模版语法
7. 计算属性、侦听器
8. 组件化框架
9. 生命周期
10. vue全家桶:(脚手架:vue-cli、 路由:vue-router、 ajax:axios库、vue:数据/状态管理)
11. 虚拟dom



1、vue数据与视图的分离、解耦(发放封闭原则:对扩展开放对修改封闭):    JQ的数据与视图不可分离,而是直接操作dom,获取改变value实现;vue可以实现数据与视图的分离,数据可以放在data里面.

以数据驱动视图:   只关心数据变化,dom操作被封装,jq不可以,vue可以

jq的视图只是一个外壳,真正的对象在dom操作里面.vue的视图可以涵盖列表里面的所有内容(v-for遍历出来)

2、MVVM的理解:

MVC:是模型(model)数据源－视图(view)－控制器(controller)的缩写

用户--view--controller--model--view

用户通过view的事件触发什么命令到控制器,控制器再去改model,然后model把自己的修改同步给view

MVVM:  (是对Mvc的一种创新)

V:view就是视图就是dom标签(视图和模型是分离的) .  view可以通过事件绑定的方式影响到model

M:model就是模型、数据    data  .    model可以通过数据绑定的方式影响到view

VM: view model,是view和model之间的桥,通过这个桥实现视图和数据分离.(是一种创新)

3、VUE实现的三要素:(3、4、5)

3、什么是响应式:修改data属性之后,vue会立刻监听到; data属性被代理到VM上

Object.defineProperty:

11、虚拟dom:

#### 为什么需要虚拟DOM，它有什么好处?

​        Web界面由DOM树(树的意思是数据结构)来构建，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化.DOM是很慢的，其元素非常庞大，页面的性能问题鲜有由JS引起的，大部分都是由DOM操作引起的。如果对前端工作进行抽象的话，主要就是维护状态和更新视图；而更新视图和维护状态都需要DOM操作。其实近年来，前端的框架主要发展方向就是解放DOM操作的复杂性。

​      虚拟DOM就是为了**解决浏览器性能问题**而被设计出来的。**如前**，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。**所以，**用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。

**JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串**

要实现从JSON对象转换为JS字符串，使用 JSON.parse() 方法：

```
`var` `obj = JSON.parse(``'{"a": "Hello", "b": "World"}'``); ``//结果是 {a: 'Hello', b: 'World'}`
```

要实现从JS对象转换为JSON字符串，使用 JSON.stringify() 方法：

```
`var` `json = JSON.stringify({a: ``'Hello'``, b: ``'World'``}); ``//结果是 '{"a": "Hello", "b": "World"}'`
```

### 单页面权限管理

在单页面中，全部采用前后端分离式设计，地址路由规则全由前端进行管理，而通信则主要采用REST标准，也就是说，后端不会向前端提供视图服务，也不会在视图模板中采用后端动态语言脚本如JSP、PHP等，但客户端首次载入应用时可能会例外，多半会提供应用的上下文、访问地址约定等信息，如REST服务地址的前缀、静态资源的访问地址信息。

      基于以上的约束，后端现在不能获取到用户访问地址信息，也自然不能判决请求的资源是否合法了，更不能返回包含权限信息的动态视图，所以现在如果完成权限的授权过程，则需要对原有的授权过程进行改进，具体过程如下。

用户发出资源请求后，前端则需要建立权限判决代理，将请求的资源信息发送给服务器；
服务器按照预定的规则判决用户是否具有访问权限，如果不通过，则提供403权限认证失败信息；
用户通过权限认证后，服务将请求的资源信息转换为前端需要的视图信息，例如视图渲染需要的模板地址信息、组件构造所需要的JS文件信息、视图ID信息等；
前端接收到视图信息后，按照路由规则注册视图，并激活视图渲染过程；

## 常用数据结构

#### 数组

在程序设计中，为了处理方便， 把具有相同类型的若干变量按有序的形式组织起来。这些按序排列的同类数据元素的集合称为数组。在C语言中， 数组属于构造数据类型。一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或是构造类型。因此按数组元素的类型不同，数组又可分为数值数组、字符数组、指针数组、结构数组等各种类别。

#### 栈

是只能在某一端插入和删除的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。

#### 队列

一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列是按照“先进先出”或“后进后出”的原则组织数据的。队列中没有元素时，称为空队列。

#### 链表

是一种物理存储单元上非连续、非顺序的存储结构，它既可以表示线性结构，也可以用于表示非线性结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

#### 树

是包含n（n>0）个结点的有穷集合K，且在K中定义了一个关系N，N满足 以下条件：
（1）有且仅有一个结点 K0，他对于关系N来说没有前驱，称K0为树的根结点。简称为根（root）。　 （2）除K0外，K中的每个结点，对于关系N来说有且仅有一个前驱。
（3）K中各结点，对关系N来说可以有m个后继（m>=0）。

#### 图

图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。

#### 堆

在计算机科学中，堆是一种特殊的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。

#### 散列表

若结构中存在关键字和K相等的记录，则必定在f(K)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数(Hash function)，按这个思想建立的表为[散列表](http://baike.baidu.com/view/1320746.htm)。

## cookie是什么

cookie是一个很小的文本文件，是浏览器储存在用户的机器上的。Cookie是纯文本，没有可执行代码。储存一些服务器需要的信息，每次请求站点，会发送相应的cookie，这些cookie可以用来辨别用户身份信息等作用。

#### cookie原理

由于http是无状态的协议，一旦客户端和服务器的数据交换完毕，就会断开连接，再次请求，会重新连接，这就说明服务器单从网络连接上是没有办法知道用户身份的。怎么办呢？那就给每次新的用户请求时，给它颁发一个身份证（独一无二）吧，下次访问，必须带上身份证，这样服务器就会知道是谁来访问了，针对不同用户，做出不同的响应。，这就是Cookie的原理。

#### 会话cookie和持久cookie。

会话cookie是一种临时cookie，用户退出浏览器，会话Cookie就会被删除了，持久cookie则会储存在硬盘里，保留时间更长，关闭浏览器，重启电脑，它依然存在，通常是持久性的cookie会维护某一个用户周期性访问服务器的配置文件或者登录信息,持久cookie 设置一个特定的过期时间（Expires）或者有效期（Max-Age）

## cookie与session区别

1. cookie数据存放在客户的浏览器上，session数据放在服务器上；
2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；
4. 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；

## websocket

WebSocket是通过单个TCP连接提供全双工（双向通信）通信信道的计算机通信协议。此WebSocket API可在用户的浏览器和服务器之间进行双向通信。用户可以向服务器发送消息并接收事件驱动的响应，而无需轮询服务器。 它可以让多个用户连接到同一个实时服务器，并通过API进行通信并立即获得响应。

## CSS+DIV三种布局方式

1、常规流式布局

2、浮动

3、定位布局